---
title: "cubids_summary_counts"
output: html_document
date: "2025-02-28"
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggplot2)
library(ggrepel)
library(dplyr)
library(stringr)
```



```{r load cubids summary, include=TRUE}
# Read cubids summary tsv file
cubids_summary <- read.delim('/Users/bsevchik/Documents/GitHub/transdiagnostic_executive_function/curation/03_cubids_curation/final_cubids_docs/v48_summary.tsv', header = TRUE, stringsAsFactors = FALSE) # local path - replace

cubids_summary
```



```{r summary cubids calculations, include=TRUE}
### Identify % dominant scans for each image modality

# Define a function to process each image type categirt
process_image_type <- function(df, pattern, extra_pattern = NULL, exclude_pattern = NULL, image_type) {
  filtered_data <- df %>%
    filter(grepl(pattern, KeyParamGroup, ignore.case = TRUE)) %>%
    filter(!grepl("fmap", KeyParamGroup, ignore.case = TRUE))  # Exclude fmap rows

  # Apply extra inclusion filter if provided
  if (!is.null(extra_pattern)) {
    filtered_data <- filtered_data %>%
      filter(grepl(extra_pattern, KeyParamGroup, ignore.case = TRUE))
  }

  # Apply exclusion filter if provided
  if (!is.null(exclude_pattern)) {
    filtered_data <- filtered_data %>%
      filter(!grepl(exclude_pattern, KeyParamGroup, ignore.case = TRUE))
  }

  # If no data matches the criteria, return NULL
  if (nrow(filtered_data) == 0) {
    return(NULL)
  }

  # Calculate the number of scans in total
  number_scans_total <- sum(filtered_data$Counts, na.rm = TRUE)
  
  # Identify the dominant scan count 
  number_scans_dominant <- max(filtered_data$Counts, na.rm = TRUE)
  
  # Compute percentage (avoid division by zero)
  percentage_dominant <- ifelse(number_scans_total > 0, 
                                (number_scans_dominant / number_scans_total) * 100, 
                                0)

  return(data.frame(
    `image type` = image_type,
    `number of scans in dominant group` = number_scans_dominant,
    `number of scans in total` = number_scans_total,
    `percentage of scans in dominant group` = percentage_dominant
  ))
}

# Define the categories with patterns in cubids_summary data frame
categories <- list(
  list(pattern = "T1w", image_type = "T1"),
  list(pattern = "dwi", image_type = "Diffusion"),
  list(pattern = "rest", extra_pattern = "run-01", image_type = "resting state fMRI run 01"),
  list(pattern = "rest", extra_pattern = "run-02", image_type = "resting state fMRI run 02"),
  list(pattern = "rest", extra_pattern = "run-03", image_type = "resting state fMRI run 03"),
  list(pattern = "nback", extra_pattern = "run-01", image_type = "task fMRI run 01"),
  list(pattern = "nback", extra_pattern = "run-02", image_type = "task fMRI run 02"),
  list(pattern = "asl", image_type = "ASL"),
  list(pattern = "m0scan", image_type = "m0 scan"),
  list(pattern = "T2w", extra_pattern = "norm", image_type = "T2w normalized"),  # Ensure only T2w with "norm"
  list(pattern = "T2w", exclude_pattern = "norm", image_type = "T2w")           # Ensure only T2w without "norm"
)

# Apply the function to each image type category
new_df_list <- lapply(categories, function(cat) {
  process_image_type(cubids_summary, cat$pattern, cat$extra_pattern, cat$exclude_pattern, cat$image_type)
})

# Combine results while handling NULL cases
cubids_image_summary <- do.call(rbind, new_df_list)


cubids_image_summary
```


```{r fmri-variant-breakdown, message=FALSE, warning=FALSE}

base <- cubids_summary %>%
  filter(!str_detect(KeyParamGroup, regex("fmap", ignore_case = TRUE)))

is_rest  <- str_detect(base$KeyParamGroup, regex("task-rest|\\brest\\b", ignore_case = TRUE))
is_nback <- str_detect(base$KeyParamGroup, regex("task-nback|\\bnback\\b", ignore_case = TRUE))

# Helper function
compute_variant_stats <- function(df, scope_label) {
  if (nrow(df) == 0) {
    return(NULL)
  }
  total <- sum(df$Counts, na.rm = TRUE)
  dominant_ct <- max(df$Counts, na.rm = TRUE)
  not_dom <- total - dominant_ct
  
  kpg <- df$KeyParamGroup
  var_numvol_mask <- str_detect(kpg, regex("VARIANTNumVolumes", ignore_case = TRUE)) |
                     str_detect(kpg, regex("VARIANTNumVolumesObliquity", ignore_case = TRUE))
  var_obliq_mask  <- str_detect(kpg, regex("VARIANTObliquity", ignore_case = TRUE))
  
  var_numvol_ct <- sum(df$Counts[var_numvol_mask], na.rm = TRUE)
  var_obliq_ct  <- sum(df$Counts[var_obliq_mask],  na.rm = TRUE)
  
  tibble(
    scope = scope_label,
    total_scans = total,
    dominant_scans = dominant_ct,
    not_dominant_scans = not_dom,
    variant_numvolumes_count = var_numvol_ct,
    variant_obliquity_count = var_obliq_ct,
    pct_variant_numvolumes_of_total = round(100 * var_numvol_ct / total, 2),
    pct_variant_obliquity_of_total  = round(100 * var_obliq_ct  / total, 2),
    pct_variant_numvolumes_of_not_dominant = if (not_dom > 0) round(100 * var_numvol_ct / not_dom, 2) else NA_real_,
    pct_variant_obliquity_of_not_dominant  = if (not_dom > 0) round(100 * var_obliq_ct  / not_dom, 2) else NA_real_
  )
}

runs <- c("run-01", "run-02", "run-03")

# Build per-task *only per-run*, no "all runs" rows
build_for_task <- function(task_label, task_mask) {
  task_df <- base[task_mask, , drop = FALSE]
  out <- list()
  for (r in runs) {
    run_df <- task_df %>% filter(str_detect(KeyParamGroup, regex(r, ignore_case = TRUE)))
    out[[length(out) + 1]] <- compute_variant_stats(run_df, paste(task_label, r))
  }
  bind_rows(out)
}

rest_tbl  <- build_for_task("rest",  is_rest)
nback_tbl <- build_for_task("nback", is_nback)

variant_summary_tbl <- bind_rows(rest_tbl, nback_tbl) %>%
  mutate(scope = factor(scope, levels = c(paste("rest", runs), paste("nback", runs)))) %>%
  arrange(scope)

variant_summary_tbl

```

